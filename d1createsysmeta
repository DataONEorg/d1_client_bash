#!/bin/bash
#
# Create system metadata for a file.
#

VERSION="1.0.0"
APPNAME=$(basename "${0}")
APPDIR=$(dirname "${0}")
TMPDIR="/tmp"
TMPNAM="${TMPDIR}/sysmeta.$$.xml"
base_url=""
dest_folder=""
MY_CLIENT_CERT="" #This is updated by script_common
NAMESPACE="http://ns.dataone.org/service/types/v1"

# possibly override initialized variables
source "${APPDIR}/script_common.sh"

# temp file destination
tmpfile="${TMPDIR}/sysmeta.$$.xml"


PID=""
format_id=""
submitter=""
rights_holder="${submitter}"
n_replicas="3"
client_certificate="${MY_CLIENT_CERT}"
fobject=""


usage()
{
cat << EOF

usage: $(basename $0) OPTIONS FILE

Create system metadata for an object.

OPTIONS:

  -h  Show this message
  -i  Identifier for object (defaults to MD5 checksum value)
  -s  Submitter subject
  -E  Client certificate, subject overrides -s
  -r  Rights holder subject, defaults to submitter if not specified
  -f  Object format identifier (${format_id})
  -n  Suggested number of replicas (${n_replicas})
  -v  Set log level (1=error ... 4=debug)
  -V  Show version (${VERSION})

FILE:

  File for which system metadata is being generated
 
EOF
}


# set $checksum to the MD5 checksum value for the file specified in $1
getFileChecksum() {
  checksum=$(md5 -q "${1}")
  ldebug "Checksum = ${checksum}"
}


# set $file_size to the size in bytes of the files specified in $1
getFileSize() {
  if [[ $(uname) -eq "Darwin" ]]; then
    file_size=$(stat -f%z "${1}")
  else
    file_size=$(stat -c%s "${1}")
  fi
  ldebug "File size = ${file_size}"
}


genBlankV1SystemMetadata() {

  local tstamp=$(date -u +%Y-%M0%dT%H:%m:%S)

  cat > ${tmpfile} << EOF
<?xml version='1.0' encoding='UTF-8'?>
<ns1:systemMetadata xmlns:ns1="${NAMESPACE}">
  <!-- 
    Warning: This file was generated by an automated process. Manual edits may 
    be overwritten without further warning.
    timestamp: ${tstamp}
    created_with: ${APPNAME}
    -->
  <serialVersion>0</serialVersion>
  <identifier>null</identifier>
  <formatId>application/octet-stream</formatId>
  <size>0</size>
  <checksum algorithm="MD5">0</checksum>
  <submitter>0</submitter>
  <rightsHolder>0</rightsHolder>
  <accessPolicy>
    <allow>
      <subject>0</subject>
      <permission>write</permission>
    </allow>
    <allow>
      <subject>public</subject>
      <permission>read</permission>
    </allow>
  </accessPolicy>
  <dateUploaded>${tstamp}.0</dateUploaded>
  <dateSysMetadataModified>${tstamp}.0</dateSysMetadataModified>
  <replicationPolicy replicationAllowed='false' />
  <authoritativeMemberNode />
  <originMemberNode />
</ns1:systemMetadata>
EOF
}



# Generate public read V1 system metadata given a bunch of parameters:
#  PID = identifier
#  format_id = object format identifier
#  file_size = size of file in bytes
#  checksum = MD5 hash of file
#  submitter = subject of submitter
#  rights_holder = subject of rights holder
#  [replication_policy] = optional replicationPolicy fragment
#  [origin_member_node] = optional originMemberNode id (will be replaced by a 
#                         MN during create)
#  [authoritative_member_mnode] = optional authoritativeMemberNode (will be 
#                         replaced by a Member Node during create)
#
# Output is to stdout
generateSystemMetadata() {
  linfo "Destination file = ${tmpfile}"

  genBlankV1SystemMetadata

  if [ -z ${PID} ]; then
    PID=${checksum}
    lwarn "Identifier set to MD5 hash value = ${PID}"
  fi

  if [ -z ${rights_holder} ]; then
    rights_holder="${submitter}"
    linfo "Rights holder set = ${rights_holder}"
  fi

  ${XML} ed -u "//identifier" -v "${PID}" \
            -u "//formatId" -v "${format_id}" \
            -u "//checksum" -v "${checksum}" \
            -u "//submitter" -v "${submitter}" \
            -u "//size" -v ${file_size} \
            -u "//rightsHolder" -v "${rights_holder}" \
            -u "//accessPolicy/allow[1]/subject" -v "${rights_holder}" \
            ${tmpfile} > ${tmpfile}.a
  mv ${tmpfile}.a ${tmpfile}
  if [[ "${n_replicas}" -gt 0 ]]; then
    ${XML} ed -u "//replicationPolicy/@replicationAllowed" -v "true" \
              -i "//replicationPolicy" -t attr -n "numberReplicas" -v "${n_replicas}" \
              ${tmpfile} > ${tmpfile}.a
    mv ${tmpfile}.a ${tmpfile}
  fi
}


# --- Main ---

while getopts ":hVv:i:s:E:r:n:" OPTION
do
    case $OPTION in
      h) usage; exit 1;;
      i) PID=${OPTARG};;
      s) submitter=${OPTARG};;
      E) client_certificate=${OPTARG};;
      r) rights_holder=${OPTARG};;
      n) n_replicas=${OPTARG};;
      v) LOGLEVEL=$OPTARG;;
      V) show_version; exit 1;;
      \?) echo "ERROR:   Invalid option: -$OPTARG";usage; exit 1;;
    esac
done

echo "level=${LOGLEVEL}"

shift $((OPTIND-1))

fobject="${1}"

if [[ ! -f "${fobject}" ]]; then
  lerror "The specified file does not exist: ${fobject}"
  exit 1
fi

if [[ -z "${submitter}" ]]; then
  submitter="${USER}"
  lwarn "Setting submitter to userid : ${submitter}"
fi

if [[ -z "${format_id}" ]]; then
  format_id="application/octet-stream"
  lwarn "Setting to default formatId of ${format_id}"
fi

getFileChecksum ${fobject}
getFileSize ${fobject}
generateSystemMetadata

cat ${tmpfile}

